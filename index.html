<!doctype html>



  


<html class="theme-next pisces use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>



<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />















  
  
  <link href="/blog/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/blog/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/blog/css/main.css?v=5.1.0" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="javascript,css,vue,angularjs" />








  <link rel="shortcut icon" type="image/x-icon" href="/blog/favicon.ico?v=5.1.0" />






<meta name="description" content="github主页">
<meta property="og:type" content="website">
<meta property="og:title" content="孙振的博客">
<meta property="og:url" content="https://sunzhen086.github.io/blog/index.html">
<meta property="og:site_name" content="孙振的博客">
<meta property="og:description" content="github主页">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="孙振的博客">
<meta name="twitter:description" content="github主页">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/blog/',
    scheme: 'Pisces',
    sidebar: {"position":"left","display":"post","offset":12,"offset_float":0,"b2t":false,"scrollpercent":false},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="https://sunzhen086.github.io/blog/"/>





  <title> 孙振的博客 </title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  














  
  
    
  

  <div class="container sidebar-position-left 
   page-home 
 ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/blog/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">孙振的博客</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">Record my life , my study , my think</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/blog/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/blog/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/blog/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            时间线
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="https://sunzhen086.github.io/blog/blog/content/排序算法解析--冒泡排序、快速排序/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="sunzhen">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="https://avatars3.githubusercontent.com/u/16077783?s=200">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="孙振的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/blog/content/排序算法解析--冒泡排序、快速排序/" itemprop="url">
                  排序算法解析--冒泡排序、快速排序
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-04-14T09:32:07+08:00">
                2017-04-14
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>时间复杂度是度量算法执行的时间长短，而空间复杂度是度量算法所需存储空间的大小。</p>
<p>算法的时间复杂度记做：T(n)=O(f(n))</p>
<p>在计算时间复杂度的时候，先找出算法的基本操作，然后根据相应的各语句确定它的执行次数，再找出T(n)的同数量级（它的同数量级有以下：1、Log2n、n、nLog2n、n的平方、n的三次方、2的n次方、n!），找出后，f(n)=该数量级，如冒泡排序的时间复杂度为T(n)=O(n*n)。</p>
<h3 id="冒泡（Bubble）排序"><a href="#冒泡（Bubble）排序" class="headerlink" title="冒泡（Bubble）排序"></a>冒泡（Bubble）排序</h3><p>冒泡排序（BubbleSort）的基本思想是：依次比较相邻的两个数，将小数放在前面，大数放在后面。如此重复下去，直至最终完成排序。</p>
<p>时间复杂度为O(n*n)，适用于排序小列表。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> arr = [<span class="number">3</span>,<span class="number">1</span>,<span class="number">4</span>,<span class="number">2</span>,<span class="number">5</span>,<span class="number">21</span>,<span class="number">6</span>,<span class="number">15</span>,<span class="number">63</span>];</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">sortA</span>(<span class="params">arr</span>)</span>&#123;</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>;i&lt;arr.length<span class="number">-1</span>;i++)&#123;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">var</span> j=i+<span class="number">1</span>;j&lt;arr.length;j++)&#123;</div><div class="line">            <span class="comment">//获取第一个值和后一个值比较</span></div><div class="line">            <span class="keyword">var</span> cur = arr[i];</div><div class="line">            <span class="keyword">if</span>(cur&gt;arr[j])&#123;</div><div class="line">                <span class="comment">// 因为需要交换值，所以会把后一个值替换，我们要先保存下来</span></div><div class="line">                <span class="keyword">var</span> index = arr[j];</div><div class="line">                <span class="comment">// 交换值</span></div><div class="line">                arr[j] = cur;</div><div class="line">                arr[i] = index;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> arr;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h3><p>快速排序（Quicksort）是对冒泡排序的一种改进，它的基本思想是：通过一趟排序将要排序的数据分割成独立的两部分，其中一部分的所有数据都比另外一部分的所有数据都要小，然后再按此方法对这两部分数据分别进行快速排序，整个排序过程可以递归进行，以此达到整个数据变成有序序列。</p>
<p>时间复杂度为O(nlog2n)，适用于排序大列表。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> arr = [<span class="number">3</span>,<span class="number">1</span>,<span class="number">4</span>,<span class="number">2</span>,<span class="number">5</span>,<span class="number">21</span>,<span class="number">6</span>,<span class="number">15</span>,<span class="number">63</span>];</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">sortA</span>(<span class="params">arr</span>)</span>&#123;</div><div class="line">    <span class="comment">// 如果只有一位，就没有必要比较</span></div><div class="line">    <span class="keyword">if</span>(arr.length&lt;=<span class="number">1</span>)&#123;</div><div class="line">        <span class="keyword">return</span> arr;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// 获取中间值的索引</span></div><div class="line">    <span class="keyword">var</span> len = <span class="built_in">Math</span>.floor(arr.length/<span class="number">2</span>);</div><div class="line">    <span class="comment">// 截取中间值</span></div><div class="line">    <span class="keyword">var</span> cur = arr.splice(len,<span class="number">1</span>);</div><div class="line">    <span class="comment">// 小于中间值放这里面</span></div><div class="line">    <span class="keyword">var</span> left = [];</div><div class="line">    <span class="comment">// 大于的放着里面</span></div><div class="line">    <span class="keyword">var</span> right = [];</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>;i&lt;arr.length;i++)&#123;</div><div class="line">        <span class="comment">// 判断是否大于</span></div><div class="line">        <span class="keyword">if</span>(cur&gt;arr[i])&#123;</div><div class="line">            left.push(arr[i]);</div><div class="line">        &#125;<span class="keyword">else</span>&#123;</div><div class="line">            right.push(arr[i]);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// 通过递归，上一轮比较好的数组合并，并且再次进行比较。</span></div><div class="line">    <span class="keyword">return</span> sortA(left).concat(cur,sortA(right));</div><div class="line">&#125;</div></pre></td></tr></table></figure>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="https://sunzhen086.github.io/blog/blog/content/对象的深度克隆/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="sunzhen">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="https://avatars3.githubusercontent.com/u/16077783?s=200">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="孙振的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/blog/content/对象的深度克隆/" itemprop="url">
                  对象的深度克隆
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-04-13T14:08:43+08:00">
                2017-04-13
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="js中的对象"><a href="#js中的对象" class="headerlink" title="js中的对象"></a>js中的对象</h1><p>谈到对象的克隆，必定要说一下对象的概念。</p>
<p>js中的数据类型分为两大类：原始类型和对象类型。</p>
<ul>
<li>原始类型包括：数值、字符串、布尔值、null、undefined</li>
<li>对象类型包括：对象即是属性的集合，当然这里又两个特殊的对象—-函数（js中的一等对象）、数组（键值的有序集合）。</li>
</ul>
<p>好了既然对象分为这两类，这两种类型在复制克隆的时候是有很大区别的。原始类型存储的是对象的实际数据，而对象类型存储的是对象的引用地址（对象的实际内容单独存放，为了减少数据开销通常存放在内存中）。ps：说到这里，大家要知道，对象的原型也是引用对象，它把原型的方法和属性放在内存当中，通过原型链的方式来指向这个内存地址。</p>
<h1 id="克隆的概念"><a href="#克隆的概念" class="headerlink" title="克隆的概念"></a>克隆的概念</h1><p>浅度克隆：原始类型为值传递，对象类型仍为引用传递。</p>
<p>深度克隆：所有元素或属性均完全复制，与原对象完全脱离，也就是说所有对于新对象的修改都不会反映到原对象中。</p>
<h1 id="浅克隆的表现"><a href="#浅克隆的表现" class="headerlink" title="浅克隆的表现"></a>浅克隆的表现</h1><h3 id="原始类型"><a href="#原始类型" class="headerlink" title="原始类型"></a>原始类型</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//数值克隆的表现</span></div><div class="line"><span class="keyword">var</span> a=<span class="string">"1"</span>;</div><div class="line"><span class="keyword">var</span> b=a;</div><div class="line">b=<span class="string">"2"</span>;</div><div class="line"><span class="built_in">console</span>.log(a);<span class="comment">// "1"</span></div><div class="line"><span class="built_in">console</span>.log(b);<span class="comment">// "2"</span></div></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//字符串克隆的表现</span></div><div class="line"><span class="keyword">var</span> c=<span class="string">"1"</span>;</div><div class="line"><span class="keyword">var</span> d=c;</div><div class="line">d=<span class="string">"2"</span>;</div><div class="line"><span class="built_in">console</span>.log(c);<span class="comment">// "1"</span></div><div class="line"><span class="built_in">console</span>.log(d);<span class="comment">// "2"</span></div></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//布尔值克隆的表现</span></div><div class="line"><span class="keyword">var</span> x=<span class="literal">true</span>;</div><div class="line"><span class="keyword">var</span> y=x;</div><div class="line">y=<span class="literal">false</span>;</div><div class="line"><span class="built_in">console</span>.log(x);<span class="comment">// true</span></div><div class="line"><span class="built_in">console</span>.log(y);<span class="comment">// false</span></div></pre></td></tr></table></figure>
<p>从上面的代码大家可以看出，原始类型即使我们采用普通的克隆方式仍能得到正确的结果，原因就是原始类型存储的是对象的实际数据。</p>
<h3 id="对象类型"><a href="#对象类型" class="headerlink" title="对象类型"></a>对象类型</h3><p>前面说过，函数式一等对象，当然也是对象类型，但是函数的克隆通过浅克隆即可实现<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> m=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;alert(<span class="number">1</span>);&#125;;</div><div class="line"><span class="keyword">var</span> n=m;</div><div class="line">n=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;alert(<span class="number">2</span>);&#125;;</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(m());<span class="comment">//1</span></div><div class="line"><span class="built_in">console</span>.log(n());<span class="comment">//2</span></div></pre></td></tr></table></figure></p>
<p>大家能看到，我们直接通过普通赋值的方式，就实现了函数的克隆，并且不会影响之前的对象。原因就是函数的克隆会在内存单独开辟一块空间，互不影响。</p>
<p>好了，说了这个特殊的”关系户“以后，我们来说说普通的”选手“。为了方便后续的代码表现，我这里定义一个复杂的对象类型oPerson。下面看一下对象类型的浅复制有什么危害：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> oPerson=&#123;</div><div class="line">    <span class="attr">oName</span>:<span class="string">"rookiebob"</span>,</div><div class="line">    <span class="attr">oAge</span>:<span class="string">"18"</span>,</div><div class="line">    <span class="attr">oAddress</span>:&#123;</div><div class="line">        <span class="attr">province</span>:<span class="string">"beijing"</span></div><div class="line">    &#125;,    </div><div class="line">    <span class="attr">ofavorite</span>:[</div><div class="line">        <span class="string">"swimming"</span>,</div><div class="line">        &#123;<span class="attr">reading</span>:<span class="string">"history book"</span>&#125;</div><div class="line">    ],</div><div class="line">    <span class="attr">skill</span>:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">        <span class="built_in">console</span>.log(<span class="string">"bob is coding"</span>);</div><div class="line">    &#125;</div><div class="line">&#125;;</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">clone</span>(<span class="params">obj</span>)</span>&#123;</div><div class="line">    <span class="keyword">var</span> result=&#123;&#125;;</div><div class="line">    <span class="keyword">for</span>(key <span class="keyword">in</span> obj)&#123;</div><div class="line">        result[key]=obj[key];</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> result;</div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> oNew=clone(oPerson);</div><div class="line"><span class="built_in">console</span>.log(oPerson.oAddress.province);<span class="comment">//beijing</span></div><div class="line">oNew.oAddress.province=<span class="string">"shanghai"</span>;</div><div class="line"><span class="built_in">console</span>.log(oPerson.oAddress.province);<span class="comment">//shanghai</span></div></pre></td></tr></table></figure></p>
<p>通过上面的代码，大家能看到，经过对象克隆以后，我修改oNew的地址，发现原对象oPerson也被修改了。这说明对象的克隆不够彻底，那也就是说深度克隆失败！</p>
<h1 id="深克隆的实现"><a href="#深克隆的实现" class="headerlink" title="深克隆的实现"></a>深克隆的实现</h1><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">deepClone</span>(<span class="params">obj,newObj</span>)</span>&#123;</div><div class="line">   <span class="keyword">var</span> newObj = newObj || &#123;&#125;;</div><div class="line">   <span class="keyword">for</span>(<span class="keyword">var</span> key <span class="keyword">in</span> obj)&#123;</div><div class="line">     <span class="keyword">if</span>(type <span class="keyword">of</span> obj == <span class="string">"object"</span>)&#123;</div><div class="line">       newObj[key] = (obj[key].constructor === <span class="built_in">Array</span>) ? [] : &#123;&#125;;</div><div class="line">       deepClone(obj[key] , newObj[key]);</div><div class="line">     &#125;<span class="keyword">else</span>&#123;</div><div class="line">       newObj[key] = obj[key];</div><div class="line">     &#125;</div><div class="line">   &#125;</div><div class="line">   <span class="keyword">return</span> newObj;</div><div class="line">&#125;</div></pre></td></tr></table></figure>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="https://sunzhen086.github.io/blog/blog/content/box-sizing属性的理解/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="sunzhen">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="https://avatars3.githubusercontent.com/u/16077783?s=200">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="孙振的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/blog/content/box-sizing属性的理解/" itemprop="url">
                  box-sizing属性的理解
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-04-13T08:51:58+08:00">
                2017-04-13
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>说到 IE 的 bug，一个臭名昭著的例子是它对于“盒模型”的错误解释：在 IE5.x 以及 Quirks 模式的 IE6/7 中，将 border 与 padding 都包含在 width 之内。这为前端工程师的工作平添了不少麻烦，几户每个需要定义尺寸的 box 都要思量一下：是否触发了“盒模型 bug”？</p>
<p>同时，由于另一撮浏览器对标准的遵从，我们在精确定义一个在有限空间内显示的 box 时，也需要计算一下：留给它的空间只有那么大，刨去 border 和 padding，我们该把它的 width 写成多少呢？</p>
<p>这种情况在 CSS3 时代有了改善，得益于这个叫做 box-sizing 的属性：</p>
<p>box-sizing属性可以为三个值之一：content-box（default），border-box，padding-box。</p>
<p>content-box，border和padding不计算入width之内</p>
<p>padding-box，padding计算入width内</p>
<p>border-box，border和padding计算入width之内，其实就是怪异模式了~</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="https://sunzhen086.github.io/blog/blog/content/常见的跨域的解决方法以及其优缺点/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="sunzhen">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="https://avatars3.githubusercontent.com/u/16077783?s=200">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="孙振的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/blog/content/常见的跨域的解决方法以及其优缺点/" itemprop="url">
                  常见的跨域的解决方法以及其优缺点
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-04-12T17:04:03+08:00">
                2017-04-12
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="1-JSONP"><a href="#1-JSONP" class="headerlink" title="1. JSONP"></a>1. JSONP</h1><p>只要说到跨域，就必须聊到 JSONP，JSONP全称为：JSON with Padding，可用于解决主流浏览器的跨域数据访问的问题。</p>
<p>Web 页面上调用 js 文件不受浏览器同源策略的影响，所以通过 Script 便签可以进行跨域的请求：</p>
<p>首先前端先设置好回调函数，并将其作为 url 的参数。<br>服务端接收到请求后，通过该参数获得回调函数名，并将数据放在参数中将其返回<br>收到结果后因为是 script 标签，所以浏览器会当做是脚本进行运行，从而达到跨域获取数据的目的。</p>
<p>优点：</p>
<ol>
<li>它不像XMLHttpRequest 对象实现 Ajax 请求那样受到同源策略的限制</li>
<li>兼容性很好，在古老的浏览器也能很好的运行</li>
<li>不需要 XMLHttpRequest 或 ActiveX 的支持；并且在请求完毕后可以通过调用 callback 的方式回传结果。</li>
</ol>
<p>缺点：</p>
<ol>
<li>它支持 GET 请求而不支持 POST 等其它类行的 HTTP 请求。</li>
<li>它只支持跨域 HTTP 请求这种情况，不能解决不同域的两个页面或 iframe 之间进行数据通信的问题</li>
</ol>
<h1 id="2-CORS"><a href="#2-CORS" class="headerlink" title="2. CORS"></a>2. CORS</h1><p>CORS 是一个 W3C 标准，全称是”跨域资源共享”（Cross-origin resource sharing）它允许浏览器向跨源服务器，发出 XMLHttpRequest 请求，从而克服了 ajax 只能同源使用的限制。</p>
<p>CORS 需要浏览器和服务器同时支持才可以生效，对于开发者来说，CORS 通信与同源的 ajax 通信没有差别，代码完全一样。浏览器一旦发现 ajax 请求跨源，就会自动添加一些附加的头信息，有时还会多出一次附加的请求，但用户不会有感觉。</p>
<p>因此，实现 CORS 通信的关键是服务器。只要服务器实现了 CORS 接口，就可以跨源通信。</p>
<p>优点：</p>
<ol>
<li>使用简单方便，更为安全</li>
<li>支持 POST 请求方式<br>缺点：</li>
<li>CORS 是一种新型的跨域问题的解决方案，存在兼容问题，仅支持 IE 10 以上</li>
</ol>
<h1 id="3-Server-Proxy"><a href="#3-Server-Proxy" class="headerlink" title="3. Server Proxy"></a>3. Server Proxy</h1><p>服务器代理，顾名思义，当你需要有跨域的请求操作时发送请求给后端，让后端帮你代为请求，然后最后将获取的结果发送给你。</p>
<h1 id="4-postMessage"><a href="#4-postMessage" class="headerlink" title="4. postMessage"></a>4. postMessage</h1><p>postMessage 是 HTML5 新增加的一项功能，跨文档消息传输(Cross Document Messaging)，目前：Chrome 2.0+、Internet Explorer 8.0+, Firefox 3.0+, Opera 9.6+, 和 Safari 4.0+ 都支持这项功能，使用起来也特别简单。</p>
<p>创建一个 iframe，使用 iframe 的一个方法 postMessage 可以想 <a href="http://localhost:8081/b.html" target="_blank" rel="external">http://localhost:8081/b.html</a> 发送消息，然后监听 message，可以获得其他文档发来的消息。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">&lt;script&gt;</div><div class="line">    <span class="comment">//子页面</span></div><div class="line">    <span class="built_in">window</span>.addEventListener(<span class="string">'message'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;</div><div class="line">        <span class="keyword">if</span>(e.source != <span class="built_in">window</span>.parent) &#123;</div><div class="line">	    <span class="keyword">return</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">let</span> data = e.data;</div><div class="line">        <span class="built_in">console</span>.log(<span class="string">'b.html 接收到的消息:'</span>, data);</div><div class="line">        parent.postMessage(<span class="string">'我已经接收到消息了!'</span>, e.origin);</div><div class="line">    &#125;);</div><div class="line"><span class="xml"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></div></pre></td></tr></table></figure>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="https://sunzhen086.github.io/blog/blog/content/学习Javascript闭包/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="sunzhen">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="https://avatars3.githubusercontent.com/u/16077783?s=200">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="孙振的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/blog/content/学习Javascript闭包/" itemprop="url">
                  学习Javascript闭包
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-04-12T16:41:42+08:00">
                2017-04-12
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>闭包（closure）是Javascript语言的一个难点，也是它的特色，很多高级应用都要依靠闭包实现。<br>下面就是我的学习笔记，对于Javascript初学者应该是很有用的。</p>
<h1 id="变量的作用域"><a href="#变量的作用域" class="headerlink" title="变量的作用域"></a>变量的作用域</h1><p>要理解闭包，首先必须理解Javascript特殊的变量作用域。<br>变量的作用域无非就是两种：全局变量和局部变量。<br>Javascript语言的特殊之处，就在于函数内部可以直接读取全局变量。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> n=<span class="number">999</span>;</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">f1</span>(<span class="params"></span>)</span>&#123;</div><div class="line">　　alert(n);</div><div class="line">&#125;</div><div class="line">f1(); <span class="comment">// 999</span></div></pre></td></tr></table></figure></p>
<p>另一方面，在函数外部自然无法读取函数内的局部变量。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">f1</span>(<span class="params"></span>)</span>&#123;</div><div class="line">　　<span class="keyword">var</span> n=<span class="number">999</span>;</div><div class="line">&#125;</div><div class="line">alert(n); <span class="comment">// error</span></div></pre></td></tr></table></figure></p>
<p>这里有一个地方需要注意，函数内部声明变量的时候，一定要使用var命令。如果不用的话，你实际上声明了一个全局变量！<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">f1</span>(<span class="params"></span>)</span>&#123;</div><div class="line">　　n=<span class="number">999</span>;</div><div class="line">&#125;</div><div class="line">f1();</div><div class="line">alert(n); <span class="comment">// 999</span></div></pre></td></tr></table></figure></p>
<h1 id="如何从外部读取局部变量？"><a href="#如何从外部读取局部变量？" class="headerlink" title="如何从外部读取局部变量？"></a>如何从外部读取局部变量？</h1><p>出于种种原因，我们有时候需要得到函数内的局部变量。但是，前面已经说过了，正常情况下，这是办不到的，只有通过变通方法才能实现。</p>
<p>那就是在函数的内部，再定义一个函数。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">f1</span>(<span class="params"></span>)</span>&#123;</div><div class="line">　　<span class="keyword">var</span> n=<span class="number">999</span>;</div><div class="line">　　<span class="function"><span class="keyword">function</span> <span class="title">f2</span>(<span class="params"></span>)</span>&#123;</div><div class="line">　　　　alert(n); <span class="comment">// 999</span></div><div class="line">　　&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>在上面的代码中，函数f2就被包括在函数f1内部，这时f1内部的所有局部变量，对f2都是可见的。但是反过来就不行，f2内部的局部变量，对f1就是不可见的。这就是Javascript语言特有的”链式作用域”结构（chain scope），子对象会一级一级地向上寻找所有父对象的变量。所以，父对象的所有变量，对子对象都是可见的，反之则不成立。<br>既然f2可以读取f1中的局部变量，那么只要把f2作为返回值，我们不就可以在f1外部读取它的内部变量了吗！<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">f1</span>(<span class="params"></span>)</span>&#123;</div><div class="line">　　<span class="keyword">var</span> n=<span class="number">999</span>;</div><div class="line">　　<span class="function"><span class="keyword">function</span> <span class="title">f2</span>(<span class="params"></span>)</span>&#123;</div><div class="line">　　　　alert(n);</div><div class="line">　　&#125;</div><div class="line">　　<span class="keyword">return</span> f2;</div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> result=f1();</div><div class="line">result(); <span class="comment">// 999</span></div></pre></td></tr></table></figure></p>
<h1 id="闭包的概念"><a href="#闭包的概念" class="headerlink" title="闭包的概念"></a>闭包的概念</h1><p>上一节代码中的f2函数，就是闭包。<br>各种专业文献上的”闭包”（closure）定义非常抽象，很难看懂。我的理解是，闭包就是能够读取其他函数内部变量的函数。<br>由于在Javascript语言中，只有函数内部的子函数才能读取局部变量，因此可以把闭包简单理解成”定义在一个函数内部的函数”。<br>所以，在本质上，闭包就是将函数内部和函数外部连接起来的一座桥梁。</p>
<h1 id="闭包的用途"><a href="#闭包的用途" class="headerlink" title="闭包的用途"></a>闭包的用途</h1><p>闭包可以用在许多地方。它的最大用处有两个，一个是前面提到的可以读取函数内部的变量，另一个就是让这些变量的值始终保持在内存中。<br>怎么来理解这句话呢？请看下面的代码。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">f1</span>(<span class="params"></span>)</span>&#123;</div><div class="line">　　<span class="keyword">var</span> n=<span class="number">999</span>;</div><div class="line">　　nAdd=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;n+=<span class="number">1</span>&#125;</div><div class="line">　　<span class="function"><span class="keyword">function</span> <span class="title">f2</span>(<span class="params"></span>)</span>&#123;</div><div class="line">　　　　alert(n);</div><div class="line">　　&#125;</div><div class="line">　　<span class="keyword">return</span> f2;</div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> result=f1();</div><div class="line">result(); <span class="comment">// 999</span></div><div class="line">nAdd();</div><div class="line">result(); <span class="comment">// 1000</span></div></pre></td></tr></table></figure></p>
<p>在这段代码中，result实际上就是闭包f2函数。它一共运行了两次，第一次的值是999，第二次的值是1000。这证明了，函数f1中的局部变量n一直保存在内存中，并没有在f1调用后被自动清除。</p>
<p>为什么会这样呢？原因就在于f1是f2的父函数，而f2被赋给了一个全局变量，这导致f2始终在内存中，而f2的存在依赖于f1，因此f1也始终在内存中，不会在调用结束后，被垃圾回收机制（garbage collection）回收。</p>
<p>这段代码中另一个值得注意的地方，就是”nAdd=function(){n+=1}”这一行，首先在nAdd前面没有使用var关键字，因此nAdd是一个全局变量，而不是局部变量。其次，nAdd的值是一个匿名函数（anonymous function），而这个匿名函数本身也是一个闭包，所以nAdd相当于是一个setter，可以在函数外部对函数内部的局部变量进行操作。</p>
<h1 id="使用闭包的注意点"><a href="#使用闭包的注意点" class="headerlink" title="使用闭包的注意点"></a>使用闭包的注意点</h1><ul>
<li>由于闭包会使得函数中的变量都被保存在内存中，内存消耗很大，所以不能滥用闭包，否则会造成网页的性能问题，在IE中可能导致内存泄露。解决方法是，在退出函数之前，将不使用的局部变量全部删除。</li>
<li>闭包会在父函数外部，改变父函数内部变量的值。所以，如果你把父函数当作对象（object）使用，把闭包当作它的公用方法（Public Method），把内部变量当作它的私有属性（private value），这时一定要小心，不要随便改变父函数内部变量的值。</li>
</ul>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="https://sunzhen086.github.io/blog/blog/content/事件委托的原理与实现/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="sunzhen">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="https://avatars3.githubusercontent.com/u/16077783?s=200">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="孙振的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/blog/content/事件委托的原理与实现/" itemprop="url">
                  事件委托的原理与实现
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-04-12T16:29:15+08:00">
                2017-04-12
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>首先，我们设定一个列表<br><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">ul</span> <span class="attr">id</span>=<span class="string">"parent-list"</span>&gt;</span></div><div class="line">	<span class="tag">&lt;<span class="name">li</span> <span class="attr">id</span>=<span class="string">"post-1"</span>&gt;</span>Item 1<span class="tag">&lt;/<span class="name">li</span>&gt;</span></div><div class="line">	<span class="tag">&lt;<span class="name">li</span> <span class="attr">id</span>=<span class="string">"post-2"</span>&gt;</span>Item 2<span class="tag">&lt;/<span class="name">li</span>&gt;</span></div><div class="line">	<span class="tag">&lt;<span class="name">li</span> <span class="attr">id</span>=<span class="string">"post-3"</span>&gt;</span>Item 3<span class="tag">&lt;/<span class="name">li</span>&gt;</span></div><div class="line">	<span class="tag">&lt;<span class="name">li</span> <span class="attr">id</span>=<span class="string">"post-4"</span>&gt;</span>Item 4<span class="tag">&lt;/<span class="name">li</span>&gt;</span></div><div class="line">	<span class="tag">&lt;<span class="name">li</span> <span class="attr">id</span>=<span class="string">"post-5"</span>&gt;</span>Item 5<span class="tag">&lt;/<span class="name">li</span>&gt;</span></div><div class="line">	<span class="tag">&lt;<span class="name">li</span> <span class="attr">id</span>=<span class="string">"post-6"</span>&gt;</span>Item 6<span class="tag">&lt;/<span class="name">li</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></div></pre></td></tr></table></figure></p>
<p>我们假设要给每个li添加不同的事件，你可以给每个独立的li元素添加事件监听器，但有时这些li元素可能会被删除，可能会有新增，监听它们的新增或删除事件将会是一场噩梦，尤其是当你的监听事件的代码放在应用的另一个地方时。但是，如果你将监听器安放到它们的父元素上呢？你如何能知道是那个子元素被点击了？</p>
<p>简单：当子元素的事件冒泡到父ul元素时，你可以检查事件对象的target属性，捕获真正被点击的节点元素的引用。下面是一段很简单的JavaScript代码，演示了事件委托的过程：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//找到父元素，添加监听器。。。  </span></div><div class="line"><span class="built_in">document</span>.getElementById(<span class="string">'parent-list'</span>).addEventListener(<span class="string">'click'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span>&#123;  </div><div class="line">    <span class="comment">//e.target是被点击的元素  </span></div><div class="line">    <span class="comment">//如果被点击的是li元素  </span></div><div class="line">    <span class="keyword">if</span>(e.target &amp;&amp; e.target.nodeName == <span class="string">'Li'</span>) &#123;  </div><div class="line">        <span class="comment">//执行操作，，，  </span></div><div class="line">        <span class="built_in">console</span>.log(<span class="string">'List item'</span>, e.target.id.replace(<span class="string">'post-'</span>), <span class="string">"was clicked"</span>)  </div><div class="line">    &#125;  </div><div class="line">&#125;)</div></pre></td></tr></table></figure></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="https://sunzhen086.github.io/blog/blog/content/兼容绑定事件的3种方法/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="sunzhen">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="https://avatars3.githubusercontent.com/u/16077783?s=200">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="孙振的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/blog/content/兼容绑定事件的3种方法/" itemprop="url">
                  兼容绑定事件的3种方法
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-04-12T16:27:00+08:00">
                2017-04-12
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="直接绑定-不利于UI和代码分离-event详见后面）"><a href="#直接绑定-不利于UI和代码分离-event详见后面）" class="headerlink" title="直接绑定(不利于UI和代码分离,event详见后面）"></a>直接绑定(不利于UI和代码分离,event详见后面）</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"button"</span> <span class="attr">onclick</span>=<span class="string">"doEventThing(event)"</span>&gt;</span></div></pre></td></tr></table></figure>
<h3 id="DOM事件句柄"><a href="#DOM事件句柄" class="headerlink" title="DOM事件句柄"></a>DOM事件句柄</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">document</span>.getElementById(<span class="string">"divid"</span>).onclick = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;;</div></pre></td></tr></table></figure>
<h3 id="侦听函数"><a href="#侦听函数" class="headerlink" title="侦听函数"></a>侦听函数</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> tb = <span class="built_in">document</span>.getelementbyid(<span class="string">"tab1"</span>);   </div><div class="line"><span class="keyword">if</span>(<span class="built_in">window</span>.event==<span class="literal">null</span>)&#123;<span class="comment">// 只有ie下，event是window的对象属性，注意两个侦听函数的区别.该方法只能在没定义event才行  </span></div><div class="line">  td.attachEvent(<span class="string">'onclick'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;alert(<span class="string">'21'</span>);&#125;);   </div><div class="line">  td.attachEvent(<span class="string">'onclick'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;alert(<span class="string">'21'</span>);&#125;)  </div><div class="line">&#125;  </div><div class="line"><span class="keyword">else</span> &#123; <span class="comment">// mozilla, netscape, firefox，w3c  </span></div><div class="line">  td.addEventListener(<span class="string">'click'</span>, alert(<span class="string">'11'</span>), <span class="literal">false</span>);   </div><div class="line">  td.addEventListener(<span class="string">'click'</span>, alert(<span class="string">'12'</span>), <span class="literal">false</span>);   </div><div class="line">&#125;</div></pre></td></tr></table></figure>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="https://sunzhen086.github.io/blog/blog/content/关于变量类型的判断/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="sunzhen">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="https://avatars3.githubusercontent.com/u/16077783?s=200">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="孙振的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/blog/content/关于变量类型的判断/" itemprop="url">
                  关于变量类型的判断
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-04-12T15:31:54+08:00">
                2017-04-12
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>在JavaScript中，有5种基本数据类型和1种复杂数据类型，基本数据类型有：Undefined, Null, Boolean, Number和String；复杂数据类型是Object，Object中还细分了很多具体的类型，比如：Array, Function, Date等等。今天我们就来探讨一下，使用什么方法判断一个出一个变量的类型。</p>
<p>在讲解各种方法之前，我们首先定义出几个测试变量，看看后面的方法究竟能把变量的类型解析成什么样子，以下几个变量差不多包含了我们在实际编码中常用的类型。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> num  = <span class="number">123</span>;</div><div class="line"><span class="keyword">var</span> str  = <span class="string">'abcdef'</span>;</div><div class="line"><span class="keyword">var</span> bool = <span class="literal">true</span>;</div><div class="line"><span class="keyword">var</span> arr  = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>];</div><div class="line"><span class="keyword">var</span> json = &#123;<span class="attr">name</span>:<span class="string">'wenzi'</span>, <span class="attr">age</span>:<span class="number">25</span>&#125;;</div><div class="line"><span class="keyword">var</span> func = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; <span class="built_in">console</span>.log(<span class="string">'this is function'</span>); &#125;</div><div class="line"><span class="keyword">var</span> und  = <span class="literal">undefined</span>;</div><div class="line"><span class="keyword">var</span> nul  = <span class="literal">null</span>;</div><div class="line"><span class="keyword">var</span> date = <span class="keyword">new</span> <span class="built_in">Date</span>();</div><div class="line"><span class="keyword">var</span> reg  = <span class="regexp">/^[a-zA-Z]&#123;5,20&#125;$/</span>;</div><div class="line"><span class="keyword">var</span> error= <span class="keyword">new</span> <span class="built_in">Error</span>();</div></pre></td></tr></table></figure>
<h3 id="使用typeof检测"><a href="#使用typeof检测" class="headerlink" title="使用typeof检测"></a>使用typeof检测</h3><p>我们平时用的最多的就是用typeof检测变量类型了。这次，我们也使用typeof检测变量的类型：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">console</span>.log(</div><div class="line">    <span class="keyword">typeof</span> num,</div><div class="line">    <span class="keyword">typeof</span> str,</div><div class="line">    <span class="keyword">typeof</span> bool,</div><div class="line">    <span class="keyword">typeof</span> arr,</div><div class="line">    <span class="keyword">typeof</span> json,</div><div class="line">    <span class="keyword">typeof</span> func,</div><div class="line">    <span class="keyword">typeof</span> und,</div><div class="line">    <span class="keyword">typeof</span> nul,</div><div class="line">    <span class="keyword">typeof</span> date,</div><div class="line">    <span class="keyword">typeof</span> reg,</div><div class="line">    <span class="keyword">typeof</span> error</div><div class="line">);</div><div class="line"><span class="comment">// number string boolean object object function undefined object object object object</span></div></pre></td></tr></table></figure>
<p>从输出的结果来看，arr, json, nul, date, reg, error 全部被检测为object类型，其他的变量能够被正确检测出来。当需要变量是否是number, string, boolean, function, undefined, json类型时，可以使用typeof进行判断。其他变量是判断不出类型的，包括null。</p>
<p>还有，typeof是区分不出array和json类型的。因为使用typeof这个变量时，array和json类型输出的都是object。</p>
<h3 id="使用instance检测"><a href="#使用instance检测" class="headerlink" title="使用instance检测"></a>使用instance检测</h3><p>在 JavaScript 中，判断一个变量的类型常常会用 typeof 运算符，在使用 typeof 运算符时采用引用类型存储值会出现一个问题，无论引用的是什么类型的对象，它都返回 “object”。ECMAScript 引入了另一个 Java 运算符 instanceof 来解决这个问题。instanceof 运算符与 typeof 运算符相似，用于识别正在处理的对象的类型。与 typeof 方法不同的是，instanceof 方法要求开发者明确地确认对象为某特定类型。例如：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>)</span>&#123;</div><div class="line"></div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> Tom = <span class="keyword">new</span> Person();</div><div class="line"><span class="built_in">console</span>.log(Tom <span class="keyword">instanceof</span> Person); <span class="comment">// true</span></div></pre></td></tr></table></figure></p>
<p>我们再看看下面的例子：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>)</span>&#123;</div><div class="line"></div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Student</span>(<span class="params"></span>)</span>&#123;</div><div class="line"></div><div class="line">&#125;</div><div class="line">Student.prototype = <span class="keyword">new</span> Person();</div><div class="line"><span class="keyword">var</span> John = <span class="keyword">new</span> Student();</div><div class="line"><span class="built_in">console</span>.log(John <span class="keyword">instanceof</span> Student); <span class="comment">// true</span></div><div class="line"><span class="built_in">console</span>.log(John instancdof Person);  <span class="comment">// true</span></div></pre></td></tr></table></figure></p>
<p>instanceof还能检测出多层继承的关系。</p>
<p>好了，我们来使用instanceof检测上面的那些变量：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">console</span>.log(</div><div class="line">    num <span class="keyword">instanceof</span> <span class="built_in">Number</span>,</div><div class="line">    str <span class="keyword">instanceof</span> <span class="built_in">String</span>,</div><div class="line">    bool <span class="keyword">instanceof</span> <span class="built_in">Boolean</span>,</div><div class="line">    arr <span class="keyword">instanceof</span> <span class="built_in">Array</span>,</div><div class="line">    json <span class="keyword">instanceof</span> <span class="built_in">Object</span>,</div><div class="line">    func <span class="keyword">instanceof</span> <span class="built_in">Function</span>,</div><div class="line">    und <span class="keyword">instanceof</span> <span class="built_in">Object</span>,</div><div class="line">    nul <span class="keyword">instanceof</span> <span class="built_in">Object</span>,</div><div class="line">    date <span class="keyword">instanceof</span> <span class="built_in">Date</span>,</div><div class="line">    reg <span class="keyword">instanceof</span> <span class="built_in">RegExp</span>,</div><div class="line">    error <span class="keyword">instanceof</span> <span class="built_in">Error</span></div><div class="line">)</div><div class="line"><span class="comment">// num : false</span></div><div class="line"><span class="comment">// str : false</span></div><div class="line"><span class="comment">// bool : false</span></div><div class="line"><span class="comment">// arr : true</span></div><div class="line"><span class="comment">// json : true</span></div><div class="line"><span class="comment">// func : true</span></div><div class="line"><span class="comment">// und : false</span></div><div class="line"><span class="comment">// nul : false</span></div><div class="line"><span class="comment">// date : true</span></div><div class="line"><span class="comment">// reg : true</span></div><div class="line"><span class="comment">// error : true</span></div></pre></td></tr></table></figure></p>
<p>从上面的运行结果我们可以看到，num, str和bool没有检测出他的类型，但是我们使用下面的方式创建num，是可以检测出类型的：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> num = <span class="keyword">new</span> <span class="built_in">Number</span>(<span class="number">123</span>);</div><div class="line"><span class="keyword">var</span> str = <span class="keyword">new</span> <span class="built_in">String</span>(<span class="string">'abcdef'</span>);</div><div class="line"><span class="keyword">var</span> boolean = <span class="keyword">new</span> <span class="built_in">Boolean</span>(<span class="literal">true</span>);</div></pre></td></tr></table></figure></p>
<p>同时，我们也要看到，und和nul是检测的Object类型，才输出的true，因为js中没有Undefined和Null的这种全局类型，他们und和nul都属于Object类型，因此输出了true。</p>
<h3 id="使用constructor检测"><a href="#使用constructor检测" class="headerlink" title="使用constructor检测"></a>使用constructor检测</h3><p>在使用instanceof检测变量类型时，我们是检测不到number, ‘string’, bool的类型的。因此，我们需要换一种方式来解决这个问题。</p>
<p>constructor本来是原型对象上的属性，指向构造函数。但是根据实例对象寻找属性的顺序，若实例对象上没有实例属性或方法时，就去原型链上寻找，因此，实例对象也是能使用constructor属性的。</p>
<p>我们先来输出一下num.constructor的内容，即数字类型的变量的构造函数是什么样子的：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Number</span>(<span class="params"></span>) </span>&#123; [native code] &#125;</div></pre></td></tr></table></figure></p>
<p>我们可以看到它指向了Number的构造函数，因此，我们可以使用num.constructor==Number来判断num是不是Number类型的，其他的变量也类似：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>)</span>&#123;</div><div class="line"></div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> Tom = <span class="keyword">new</span> Person();</div><div class="line"></div><div class="line"><span class="comment">// undefined和null没有constructor属性</span></div><div class="line"><span class="built_in">console</span>.log(</div><div class="line">    Tom.constructor==Person,</div><div class="line">    num.constructor==<span class="built_in">Number</span>,</div><div class="line">    str.constructor==<span class="built_in">String</span>,</div><div class="line">    bool.constructor==<span class="built_in">Boolean</span>,</div><div class="line">    arr.constructor==<span class="built_in">Array</span>,</div><div class="line">    json.constructor==<span class="built_in">Object</span>,</div><div class="line">    func.constructor==<span class="built_in">Function</span>,</div><div class="line">    date.constructor==<span class="built_in">Date</span>,</div><div class="line">    reg.constructor==<span class="built_in">RegExp</span>,</div><div class="line">    error.constructor==<span class="built_in">Error</span></div><div class="line">);</div><div class="line"><span class="comment">// 所有结果均为true</span></div></pre></td></tr></table></figure>
<p>从输出的结果我们可以看出，除了undefined和null，其他类型的变量均能使用constructor判断出类型。</p>
<p>不过使用constructor也不是保险的，因为constructor属性是可以被修改的，会导致检测出的结果不正确，例如：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>)</span>&#123;</div><div class="line"></div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Student</span>(<span class="params"></span>)</span>&#123;</div><div class="line"></div><div class="line">&#125;</div><div class="line">Student.prototype = <span class="keyword">new</span> Person();</div><div class="line"><span class="keyword">var</span> John = <span class="keyword">new</span> Student();</div><div class="line"><span class="built_in">console</span>.log(John.constructor==Student); <span class="comment">// false</span></div><div class="line"><span class="built_in">console</span>.log(John.constructor==Person);  <span class="comment">// true</span></div></pre></td></tr></table></figure>
<p>在上面的例子中，Student原型中的constructor被修改为指向到Person，导致检测不出实例对象John真实的构造函数。</p>
<p>同时，使用instaceof和construcor,被判断的array必须是在当前页面声明的！比如，一个页面（父页面）有一个框架，框架中引用了一个页面（子页面），在子页面中声明了一个array，并将其赋值给父页面的一个变量，这时判断该变量，Array == object.constructor;会返回false；<br>原因：<br>1、array属于引用型数据，在传递过程中，仅仅是引用地址的传递。<br>2、每个页面的Array原生对象所引用的地址是不一样的，在子页面声明的array，所对应的构造函数，是子页面的Array对象；父页面来进行判断，使用的Array并不等于子页面的Array；切记，不然很难跟踪问题！</p>
<h3 id="使用Object-prototype-toString-call"><a href="#使用Object-prototype-toString-call" class="headerlink" title="使用Object.prototype.toString.call"></a>使用Object.prototype.toString.call</h3><p>我们先不管这个是什么，先来看看他是怎么检测变量类型的：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">console</span>.log(</div><div class="line">    <span class="built_in">Object</span>.prototype.toString.call(num),</div><div class="line">    <span class="built_in">Object</span>.prototype.toString.call(str),</div><div class="line">    <span class="built_in">Object</span>.prototype.toString.call(bool),</div><div class="line">    <span class="built_in">Object</span>.prototype.toString.call(arr),</div><div class="line">    <span class="built_in">Object</span>.prototype.toString.call(json),</div><div class="line">    <span class="built_in">Object</span>.prototype.toString.call(func),</div><div class="line">    <span class="built_in">Object</span>.prototype.toString.call(und),</div><div class="line">    <span class="built_in">Object</span>.prototype.toString.call(nul),</div><div class="line">    <span class="built_in">Object</span>.prototype.toString.call(date),</div><div class="line">    <span class="built_in">Object</span>.prototype.toString.call(reg),</div><div class="line">    <span class="built_in">Object</span>.prototype.toString.call(error)</div><div class="line">);</div><div class="line"><span class="comment">// '[object Number]' '[object String]' '[object Boolean]' '[object Array]' '[object Object]'</span></div><div class="line"><span class="comment">// '[object Function]' '[object Undefined]' '[object Null]' '[object Date]' '[object RegExp]' '[object Error]'</span></div></pre></td></tr></table></figure></p>
<p>从输出的结果来看，Object.prototype.toString.call(变量)输出的是一个字符串，字符串里有一个数组，第一个参数是Object，第二个参数就是这个变量的类型，而且，所有变量的类型都检测出来了，我们只需要取出第二个参数即可。或者可以使用Object.prototype.toString.call(arr)==”object Array”来检测变量arr是不是数组。</p>
<h3 id="jquery中-type的实现"><a href="#jquery中-type的实现" class="headerlink" title="jquery中$.type的实现"></a>jquery中$.type的实现</h3><p>在jquery中提供了一个$.type的接口，来让我们检测变量的类型：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">console</span>.log(</div><div class="line">    $.type(num),</div><div class="line">    $.type(str),</div><div class="line">    $.type(bool),</div><div class="line">    $.type(arr),</div><div class="line">    $.type(json),</div><div class="line">    $.type(func),</div><div class="line">    $.type(und),</div><div class="line">    $.type(nul),</div><div class="line">    $.type(date),</div><div class="line">    $.type(reg),</div><div class="line">    $.type(error)</div><div class="line">);</div><div class="line"><span class="comment">// number string boolean array object function undefined null date regexp error</span></div></pre></td></tr></table></figure></p>
<p>看到输出结果，有没有一种熟悉的感觉？对，他就是上面使用Object.prototype.toString.call(变量)输出的结果的第二个参数呀。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="https://sunzhen086.github.io/blog/blog/content/常见的原生javascript DOM操作/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="sunzhen">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="https://avatars3.githubusercontent.com/u/16077783?s=200">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="孙振的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/blog/content/常见的原生javascript DOM操作/" itemprop="url">
                  常见的原生javascript DOM操作
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-04-11T16:03:28+08:00">
                2017-04-11
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="创建元素"><a href="#创建元素" class="headerlink" title="创建元素"></a>创建元素</h1><blockquote>
<p>创建元素：document.createElement()</p>
</blockquote>
<p>使用document.createElement()可以创建新元素。这个方法只接受一个参数，即要创建元素的标签名。这个标签名在HTML文档中不区分大小写，在XHTML中区分大小写。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> div = <span class="built_in">document</span>.createElement(<span class="string">"div"</span>);</div></pre></td></tr></table></figure></p>
<p>使用createElement()方法创建新元素的同时，也为新元素设置了ownerDocument属性，可以操作元素的特性。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">div.id = <span class="string">"myDiv"</span>;</div><div class="line">div.className = <span class="string">"div1"</span>;</div></pre></td></tr></table></figure></p>
<p>此时，新元素尚未被添加到文档树中，因此设置各种特性均不会影响浏览器的显示。要添加到文档树，可用appendChild()、insertBefore()、replaceChild()。（稍后讲到）<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">document</span>.body.appendChild(div);</div></pre></td></tr></table></figure></p>
<p>当把元素添加到文档树中后，这个元素做的任何修改都会实时地反应到浏览器中。</p>
<p>在IE中可以为createElement()方法传入完整的元素标签和属性。(只在IE中兼容)<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> div = <span class="built_in">document</span>.createElement(<span class="string">"&lt;div id=\"mydiv\" class=\"div1\"&gt;&lt;/div&gt;"</span>);</div><div class="line"><span class="comment">//不能再标签里加其他元素节点或者文本节点，如下的方式和上面的得出的节点一样</span></div><div class="line"><span class="keyword">var</span> div = <span class="built_in">document</span>.createElement(<span class="string">"&lt;div id=\"mydiv\" class=\"div1\"&gt;12212&lt;/div&gt;"</span>);</div></pre></td></tr></table></figure></p>
<blockquote>
<p>创建文本节点 ：document.createTextNode</p>
</blockquote>
<p>使用document.createTextNode()来创建文本节点，这个方法接受一个参数：要插入节点的文本。与设置已有文本节点的值一样，作为参数的文本将按照HTML或XML的格式进行编码。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">document</span>.createTextNode(<span class="string">"121212"</span>);</div></pre></td></tr></table></figure></p>
<p>可以添加多个文本节点。假如两个文本节点时相邻的同胞节点，那么两个文本节点会连起来，中间不会有空格。</p>
<h1 id="节点关系"><a href="#节点关系" class="headerlink" title="节点关系"></a>节点关系</h1><p>文本关系如下：<br><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"div1"</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"div2"</span>&gt;</span>2<span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"div3"</span>&gt;</span>3<span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"div4"</span>&gt;</span>4<span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></div></pre></td></tr></table></figure></p>
<blockquote>
<p>父节点：parentNode</p>
</blockquote>
<p>parentNode是指定节点的父节点.一个元素节点的父节点可能是一个元素(Element )节点,也可能是一个文档(Document )节点,或者是个文档碎片(DocumentFragment)节点.<br>每一个节点都有一个parentNode属性。</p>
<p>对于下面的节点类型: Attr, Document, DocumentFragment, Entity, Notation,其parentNode属性返回null。如果当前节点刚刚被建立,还没有被插入到DOM树中,则该节点的parentNode属性也返回null。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span>&gt;</span><span class="javascript"></span></div><div class="line">    <span class="keyword">var</span> child2 = <span class="built_in">document</span>.getElementById(<span class="string">"div2"</span>);</div><div class="line">    <span class="keyword">var</span> parent = child2.parentNode;</div><div class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></div></pre></td></tr></table></figure>
<blockquote>
<p>子节点：childNodes</p>
</blockquote>
<p>childNodes 返回包含指定节点的子节点的集合，该集合为即时更新的集合（live collection）。<br>即时更新就是对节点元素的任意修改都会立即反映到结果里。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span>&gt;</span><span class="javascript"></span></div><div class="line">    <span class="keyword">var</span> child2 = <span class="built_in">document</span>.getElementById(<span class="string">"div2"</span>);</div><div class="line">    <span class="keyword">var</span> parent = child2.parentNode;</div><div class="line">    <span class="keyword">var</span> allChilds = parent.childNodes;</div><div class="line">    <span class="comment">/**</span></div><div class="line">      在IE6下才会返回3</div><div class="line">      在其他浏览器中会返回3个div节点+3个div节点的文本节点+1个自己的文本节点=7</div><div class="line">      下同</div><div class="line">    **/</div><div class="line">    <span class="built_in">console</span>.log(allChilds.length) <span class="comment">// IE下是3，其他浏览器是7</span></div><div class="line"></div><div class="line"></div><div class="line">    <span class="keyword">var</span> nodeAdd = <span class="built_in">document</span>.createElement(<span class="string">"div"</span>);</div><div class="line">    <span class="keyword">var</span> textAdd = <span class="built_in">document</span>.createTextNode(<span class="string">"这是添加的文本节点"</span>);</div><div class="line">    nodeAdd.appendChild(textAdd);</div><div class="line">    parent.appendChild(nodeAdd);</div><div class="line">    <span class="built_in">console</span>.log(allChilds.length);<span class="comment">// IE下是4，其他浏览器是8</span></div><div class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></div></pre></td></tr></table></figure>
<blockquote>
<p>兄弟节点：nextSibling，previousSibling</p>
</blockquote>
<p>nextSibling返回某节点的下一个兄弟节点，previousSibling返回某节点的上一个兄弟节点，没有的话返回null。<br>注意：可能因为元素换行的原因返回的是text节点。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">&lt;script type=<span class="string">"text/javascript"</span>&gt;</div><div class="line">    <span class="keyword">var</span> child3 = <span class="built_in">document</span>.getElementById(<span class="string">"div3"</span>);</div><div class="line">    <span class="keyword">var</span> next = child3.nextSibling;</div><div class="line">    <span class="keyword">var</span> previous = child3.previousSibling;</div><div class="line">    <span class="built_in">console</span>.log(next); <span class="comment">// IE下返回div4，其他返回text</span></div><div class="line">    <span class="built_in">console</span>.log(previous)  <span class="comment">// IE下返回div2，其他返回text</span></div><div class="line">&lt;<span class="regexp">/script&gt;</span></div></pre></td></tr></table></figure></p>
<blockquote>
<p>第一个或最后一个子节点：firstChild、lastChild</p>
</blockquote>
<p>firstChild返回node的子节点中的第一个节点的引用，没有返回null<br>lastChild返回node的子节点中的最后一个节点的引用，没有返回null<br><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span>&gt;</span><span class="javascript"></span></div><div class="line">    <span class="keyword">var</span> child3 = <span class="built_in">document</span>.getElementById(<span class="string">"div3"</span>);</div><div class="line">    <span class="keyword">var</span> parent = child3.parentNode;</div><div class="line">    <span class="keyword">var</span> first = parent.firstChild; <span class="comment">// IE是div2，其他是text</span></div><div class="line">    <span class="keyword">var</span> last = parent.lastChild; <span class="comment">// IE是div4，其他是text</span></div><div class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></div></pre></td></tr></table></figure></p>
<h1 id="节点元素关系"><a href="#节点元素关系" class="headerlink" title="节点元素关系"></a>节点元素关系</h1><p>只算元素，不算文本节点。</p>
<p>以下三个方法用法和节点关系完全一样，只是这三个方法只看元素节点，不管因为空格、换行造成的文本节点或者手动加上去的文本节点。<br>children： 返回所有元素子节点（IE5+、ff3.5、opera3、chrome，但在IE8及以下会将注释节点看成一个元素节点）</p>
<p>以下两个IE9+才支持<br>nextElementSibling：返回元素的下一个兄弟元素节点<br>previousElementSibling: 返回元素的上一个兄弟元素节点</p>
<h1 id="节点元素关系-1"><a href="#节点元素关系-1" class="headerlink" title="节点元素关系"></a>节点元素关系</h1><blockquote>
<p>appendChild()</p>
</blockquote>
<p>appendChild()用于向childNodes列表的末尾添加一个节点，并且返回这个新增的节点。<br>如果传入到appendChild()里的节点已经是文档的一部分了，那结果就是将节点从原来的位置转移到新位置，任何一个节点不能同时出现在文档中的多个位置。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> returnNode = someNode.appendChild(someNode.firstChild); <span class="comment">// 返回第一个节点</span></div><div class="line"><span class="built_in">console</span>.log(returnNode === someNode.firstChild); <span class="comment">// false</span></div><div class="line"><span class="built_in">console</span>.log(returnNode === someNode.lastChild); <span class="comment">// true</span></div></pre></td></tr></table></figure>
<blockquote>
<p>insetBefore()</p>
</blockquote>
<p>insetBefore()可以将节点插入到某个特定的位置。这个方法接受两个参数：要插入的节点和作为参照的节点。<br>插入节点后，被插入的节点变成参照节点的前一个同胞节点，同时被方法返回。 如果参照节点是null，则与appendChild()执行相同的操作。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 插入后成为最后一个子节点</span></div><div class="line"><span class="keyword">var</span> returnNode = someNode.insetBefore(newNode, <span class="literal">null</span>);</div><div class="line"><span class="built_in">console</span>.log(returnNode === someNode.lastChild); <span class="comment">// true</span></div><div class="line"></div><div class="line"><span class="comment">// 插入后成为第一个子节点</span></div><div class="line"><span class="keyword">var</span> returnNode = someNode.insetBefore(newNode, someNode.firstChild);</div><div class="line"><span class="built_in">console</span>.log(returnNode === newNode); <span class="comment">// true</span></div><div class="line"><span class="built_in">console</span>.log(returnNode === someNode.firstChild); <span class="comment">// true</span></div><div class="line"></div><div class="line"><span class="comment">// 插入到最后一个子节点的前面</span></div><div class="line"><span class="keyword">var</span> returnNode = someNode.insetBefore(newNode, someNode.lastChild);</div><div class="line"><span class="built_in">console</span>.log(returnNode === someNode.childNodes[someNode.childnodes.length - <span class="number">2</span>]) <span class="comment">// true</span></div></pre></td></tr></table></figure>
<blockquote>
<p>替换节点： replaceChild()</p>
</blockquote>
<p>replaceChild()接受两个参数：要插入的节点和要被替换的节点。被替换的节点将由这个方法返回并从文档中被移除，同时由要插入的节点占据其位置。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 替换第一个子节点</span></div><div class="line"><span class="keyword">var</span> returnNode = someNode.replaceChild(newNode, someNode.firstChild);</div></pre></td></tr></table></figure></p>
<p>使用replaceChild()后，被替换的节点的所有关系指针都会被复制到插入的节点上面。</p>
<blockquote>
<p>删除节点：removeChild()</p>
</blockquote>
<p>该方法移除节点，接受一个参数，即要移除的节点，同时该方法返回被移除的节点。只能是一个节点，不能是一组节点。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 移除第一个子节点</span></div><div class="line"><span class="keyword">var</span> returnNode = someNode.removeChild(newNode, someNode.firstChild);</div></pre></td></tr></table></figure></p>
<blockquote>
<p>克隆节点：cloneNode(true/false)</p>
</blockquote>
<p>返回调用该方法的节点的一个副本。参数表示是否采用深度克隆,如果为true,则该节点的所有后代节点也都会被克隆,如果为false,则只克隆该节点本身，文本或者换行、空格这些不会复制，因为他们都是一个textNode。</p>
<p>注意: 在DOM4规范中(实现于Gecko 13.0(Firefox 13.0 / Thunderbird 13.0 / SeaMonkey 2.10) , 查看 bug 698391),deep是一个可选参数. 如果省略的话, deep参数的默认值为true,也就是说,深度克隆是默认的.如果想使用浅克隆, 你需要将该参数指定为false。</p>
<p>在旧版本的浏览器中, 你始终需要指定deep参数。</p>
<p>克隆一个元素节点会拷贝它所有的属性以及属性值,当然也就包括了属性上绑定的事件(比如onclick=”alert(1)”),但不会拷贝那些使用addEventListener()方法或者node.onclick = fn这种用JavaScript动态绑定的事件。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> div1 = <span class="built_in">document</span>.getElementById(<span class="string">"div1"</span>);</div><div class="line"><span class="keyword">var</span> cloneHtml = div1.cloneNode(<span class="literal">true</span>);</div><div class="line"><span class="built_in">document</span>.body.appendChild(cloneHtml);</div></pre></td></tr></table></figure>
<h1 id="元素选择"><a href="#元素选择" class="headerlink" title="元素选择"></a>元素选择</h1><p>HTML代码示例：<br><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"div1"</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">p</span> <span class="attr">id</span>=<span class="string">"div2"</span> <span class="attr">class</span>=<span class="string">"one"</span> <span class="attr">name</span>=<span class="string">"nameone"</span>&gt;</span>2<span class="tag">&lt;/<span class="name">p</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"div3"</span>&gt;</span>3<span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"div4"</span> <span class="attr">name</span>=<span class="string">"div2"</span>&gt;</span>4<span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></div></pre></td></tr></table></figure></p>
<blockquote>
<p>querySelector、querySelectorAll(IE8及以上)</p>
</blockquote>
<p>Selectors API通过匹配一组选择器的方式来为从DOM中检索Element节点提供一些简单快捷的方法，这比过去必须要在javascript代码中用循环来查找某个你想要的特定元素更快一些。<br>该规范对于使用Document,DocumentFragment和Element接口的对象都增了两种新方法：</p>
<p>querySelector<br>返回节点子树内与之相匹配的第一个Element节点。如果没有匹配的节点，则返回null。</p>
<p>querySelectorAll<br>返回一个包含节点子树内所有与之相匹配的Element节点列表，如果没有相匹配的，则返回一个空节点列表。</p>
<p>注意：由 querySelector()、querySelectorAll()返回的节点列表不是动态实时的（非live Collection）。这和其他DOM查询方法返回动态实时节点列表不一样。</p>
<p>选择器方法接受一个或多个用逗号分隔的选择器来确定需要被返回的元素。例如，要选择文档中所有CSS的类(class)是warning或者note的段落(p)元素,可以这样写：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> special = <span class="built_in">document</span>.querySelectorAll( <span class="string">"p.warning, p.note"</span> );</div></pre></td></tr></table></figure></p>
<p>也可以通过ID来查询，例如：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> el = <span class="built_in">document</span>.querySelector( <span class="string">"#main, #basic, #exclamation"</span> );</div></pre></td></tr></table></figure></p>
<p>执行上面的代码后，el就包含了文档中元素的ID是main，basic或exclamation的所有元素中的第一个元素。</p>
<p>querySelector() and querySelectorAll() 里可以使用任何CSS选择器，他们都不是live Collection：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> notLive = <span class="built_in">document</span>.querySelectorAll(<span class="string">"p"</span>);</div><div class="line"><span class="built_in">console</span>.log(notLive);</div><div class="line"><span class="built_in">document</span>.getElementById(<span class="string">"div1"</span>).removeChild(<span class="built_in">document</span>.getElementById(<span class="string">"div2"</span>));</div><div class="line"><span class="built_in">console</span>.log(notLive);</div><div class="line"><span class="comment">// 上面两个输出都是输出 `p#div2.one`的引用，没有因为删除了`p`标签而使`notLive`的结果发生变化。</span></div></pre></td></tr></table></figure></p>
<blockquote>
<p>getElementById()</p>
</blockquote>
<p>返回一个匹配特定 ID的元素。id是大小写敏感的字符串，代表了所要查找的元素的唯一ID，如果没有则返回null。<br>如果新建一个元素，还没有插入到文档中，则不能通过该方法获取到。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> notLive = <span class="built_in">document</span>.getElementById(<span class="string">"div2"</span>);</div><div class="line"><span class="built_in">console</span>.log(notLive.innerHTML);</div><div class="line"><span class="built_in">document</span>.getElementById(<span class="string">"div1"</span>).removeChild(<span class="built_in">document</span>.getElementById(<span class="string">"div2"</span>));</div><div class="line"><span class="built_in">console</span>.log(notLive.innerHTML);</div><div class="line"><span class="comment">// 上面输出都是2，说明getElementById()也是**非**live collection</span></div></pre></td></tr></table></figure></p>
<blockquote>
<p>getElementsByTagName()</p>
</blockquote>
<p>document.getElementsByTagName() 方法返回一个实时的包含具有给出标签名的元素们的HTMLCollection。指定的元素的子树会被搜索，包括元素自己。返回的 list 是实时的（live collection），意味着它会随着DOM树的变化自动更新。因此，如果对同一个元素，使用相同的参数，是不需要多次调用document.getElementsByTagName() 的。</p>
<p>Element.getElementsByTagName()的搜索被限制为指定元素的后代而不是document</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> live = <span class="built_in">document</span>.getElementsByTagName(<span class="string">"p"</span>);</div><div class="line"><span class="built_in">console</span>.log(live[<span class="number">0</span>].innerHTML);</div><div class="line"><span class="built_in">document</span>.getElementById(<span class="string">"div1"</span>).removeChild(<span class="built_in">document</span>.getElementById(<span class="string">"div2"</span>));</div><div class="line"><span class="built_in">console</span>.log(live[<span class="number">0</span>].innerHTML);</div><div class="line"><span class="comment">// 第一个输出2，第二个报错，因为无法引用到p标签</span></div></pre></td></tr></table></figure>
<blockquote>
<p>getElementsByName()</p>
</blockquote>
<p>该方法返回一个实时的nodelist collection，包含文档中所有name属性匹配的标签。这是一个<strong>live collection</strong>。<br>注意：在IE和opera下，如果某个元素1的name和另一个元素2的id重合，且元素2在元素1的前面，则getElementsByName()会取到元素2。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> live = <span class="built_in">document</span>.getElementsByName(<span class="string">"div2"</span>);</div><div class="line"><span class="built_in">console</span>.log(live[<span class="number">0</span>].innerHTML);</div><div class="line"><span class="built_in">document</span>.getElementById(<span class="string">"div1"</span>).removeChild(<span class="built_in">document</span>.getElementById(<span class="string">"div2"</span>));</div><div class="line"><span class="built_in">console</span>.log(live[<span class="number">0</span>].innerHTML);</div><div class="line"><span class="comment">// chrome下：全部输出4</span></div><div class="line"><span class="comment">// IE下： 第一个输出2，第二个报错。</span></div></pre></td></tr></table></figure>
<blockquote>
<p>getElementsByClassName()</p>
</blockquote>
<p>该方法返回一个即时更新的（live） HTMLCollection，包含了所有拥有指定 class 的子元素。当在 document 对象上调用此方法时，会检索整个文档，包括根元素。(IE9以下不支持)</p>
<p>要匹配多个class，则className用空格分开。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">getElementsByClassName(<span class="string">"class1 class2"</span>);</div></pre></td></tr></table></figure></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> live = <span class="built_in">document</span>.getElementsByClassName(<span class="string">"one"</span>);</div><div class="line"><span class="built_in">console</span>.log(live[<span class="number">0</span>].innerHTML);</div><div class="line"><span class="built_in">document</span>.getElementById(<span class="string">"div1"</span>).removeChild(<span class="built_in">document</span>.getElementById(<span class="string">"div2"</span>));</div><div class="line"><span class="built_in">console</span>.log(live[<span class="number">0</span>].innerHTML);</div><div class="line"><span class="comment">// 第一个返回2，第二个报错</span></div></pre></td></tr></table></figure>
<h1 id="属性操作"><a href="#属性操作" class="headerlink" title="属性操作"></a>属性操作</h1><blockquote>
<p>setAttribute()</p>
</blockquote>
<p>添加一个新属性（attribute）到元素上，或改变元素上已经存在的属性的值。</p>
<p>当在 HTML 文档中的 HTML 元素上调用 setAttribute() 方法时，该方法会将其属性名称（attribute name）参数小写化。</p>
<p>如果指定的属性已经存在，则其值变为传递的值。如果不存在，则创建指定的属性。也可指定为null。如果设置为null，最好使用removeAttribute()。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> div2 = <span class="built_in">document</span>.getElementById(<span class="string">"div2"</span>);</div><div class="line">div2.setAttribute(<span class="string">"class"</span>, <span class="string">"new_class"</span>);</div><div class="line">div2.setAttribute(<span class="string">"id"</span>, <span class="string">"new_id"</span>);</div></pre></td></tr></table></figure>
<p>注意：在IE7下，修改了元素的class，如果已有class，则会出现两个class，通过setAttribute()添加的不生效；如果没有class，则添加上class，但这个添加上去的class的样式不会生效。</p>
<blockquote>
<p>removeAttribute()</p>
</blockquote>
<p>该方法用于移除元素的属性。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> div2 = <span class="built_in">document</span>.getElementById(<span class="string">"div2"</span>);</div><div class="line">div2.removeAttribute(<span class="string">"class"</span>);</div></pre></td></tr></table></figure></p>
<p>注意：IE7下无法移除 class 属性</p>
<blockquote>
<p>getAttribute()</p>
</blockquote>
<p>该方法返回元素上指定属性（attribute）的值。如果指定的属性不存在，则返回 null 或 “” （空字符串）（IE5+都返回null）。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> div2 = <span class="built_in">document</span>.getElementById(<span class="string">"div2"</span>);</div><div class="line"><span class="keyword">var</span> attr = div2.getAttribute(<span class="string">"class"</span>);</div><div class="line"><span class="built_in">console</span>.log(attr);</div></pre></td></tr></table></figure></p>
<p>注意：IE7下不能正确返回class，返回的是null，其他正常。</p>
<blockquote>
<p>hasAttribute()</p>
</blockquote>
<p>hasAttribute() 返回一个布尔值，指示该元素是否包含有指定的属性（attribute）。</p>
<p>注意：IE7不支持该方法。</p>
<blockquote>
<p>自定义属性data-*</p>
</blockquote>
<p>html5里有一个data-*去设置获取元素的自定义属性值。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;div id=<span class="string">"div1"</span> data-aa=<span class="string">"11"</span>&gt;</div></pre></td></tr></table></figure></p>
<p>利用div1.dataset可以获得一个DOMStringMap，包含了元素的所有data-*。<br>使用div1.dataset.aa就可以获取11的值。<br>同样，通过设置div1.dataset.bb = “22”就可以设置一个自定义属性值。<br>在不兼容的浏览器里，就使用getAttribute和setAttribute</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> div1 = <span class="built_in">document</span>.getElementById(<span class="string">"div1"</span>);</div><div class="line"><span class="keyword">var</span> a = <span class="literal">null</span>;</div><div class="line"><span class="keyword">if</span> (div1.dataset) &#123;</div><div class="line">    a = div1.dataset.aa;</div><div class="line">    div1.dataset.bb = <span class="string">"222"</span>;</div><div class="line">&#125; <span class="keyword">else</span> &#123;</div><div class="line">    a = div1.getAttribute(<span class="string">"data-aa"</span>);</div><div class="line">    div1.setAttribute(<span class="string">"data-bb"</span>, <span class="string">"2222"</span>);</div><div class="line">&#125;</div><div class="line"><span class="built_in">console</span>.log(a);</div></pre></td></tr></table></figure>
<h1 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h1><blockquote>
<p>addEventListener()</p>
</blockquote>
<p>addEventListener()将指定的事件监听器注册到目标对象上，当目标对象触发指定的事件时，指定的回调函数就会触发。目标对象可以是 文档上的元素、 document、 window 或者XMLHttpRequest(比如onreadystatechange事件)。</p>
<p>IE8及以下不支持此方法且只有事件冒泡没有事件捕获。IE9开始支持此方法，也就有了事件捕获。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> div1 = <span class="built_in">document</span>.getElementById(<span class="string">"div1"</span>);</div><div class="line">div1.addEventListener(<span class="string">"click"</span>, listener, <span class="literal">false</span>);</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">listener</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">'test'</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> cloneHtml = div1.cloneNode(<span class="literal">true</span>);</div><div class="line"><span class="built_in">document</span>.body.appendChild(cloneHtml);</div></pre></td></tr></table></figure>
<p>第一个参数是事件名，第二个是回调函数，第三个参数为true表示捕获，false表示冒泡。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> div1 = <span class="built_in">document</span>.getElementById(<span class="string">"div1"</span>);</div><div class="line">div1.addEventListener(<span class="string">"click"</span>, listener1, <span class="literal">true</span>/fasle);</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">listener1</span>(<span class="params"></span>) </span>&#123;</div><div class="line">   <span class="built_in">console</span>.log(<span class="string">'test1'</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> div2 = <span class="built_in">document</span>.getElementById(<span class="string">"div2"</span>);</div><div class="line">div2.addEventListener(<span class="string">"click"</span>, listener2, <span class="literal">true</span>/fasle);</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">listener2</span>(<span class="params"></span>) </span>&#123;</div><div class="line">   <span class="built_in">console</span>.log(<span class="string">'test2'</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>有一点要注意的是，当对某一个元素1既绑定了捕获事件，又绑定了冒泡事件时：<br>当这个元素1并不是触发事件的那个元素2时，则触发顺序会按照先 捕获 后 冒泡 的顺序触发；<br>当这个元素1就是最底层的触发事件的元素时，则这个元素没有捕获和冒泡的区别，谁先绑定就先触发谁。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> div2 = <span class="built_in">document</span>.getElementById(<span class="string">"div2"</span>);</div><div class="line"></div><div class="line">div2.addEventListener(<span class="string">"click"</span>, listener2, <span class="literal">true</span>);</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">listener2</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">'test2'</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line">div2.addEventListener(<span class="string">"click"</span>, listener1, <span class="literal">false</span>);</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">listener1</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">'test1'</span>);</div><div class="line">&#125;</div><div class="line"><span class="comment">// 按绑定顺序执行，两个`addEventLister()`颠倒过来则执行顺序也变化</span></div><div class="line"><span class="comment">// 如果再对`div1`绑定一个捕获、一个冒泡，则会先触发捕获 再 触发冒泡，与绑定顺序无关</span></div></pre></td></tr></table></figure>
<blockquote>
<p>removeEventListener()</p>
</blockquote>
<p>与addEventListener()绑定事件对应的就是移除已绑定的事件。第三个参数的布尔值代表解绑的是捕获事件还是冒泡事件。两个事件互不相关。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> div2 = <span class="built_in">document</span>.getElementById(<span class="string">"div2"</span>);</div><div class="line">div2.addEventListener(<span class="string">"click"</span>, listener2, <span class="literal">true</span>);</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">listener2</span>(<span class="params"></span>) </span>&#123;</div><div class="line">   <span class="built_in">console</span>.log(<span class="string">'test2'</span>);</div><div class="line">&#125;</div><div class="line">div2.removeEventListener(<span class="string">"click"</span>, listener2, <span class="literal">true</span>);</div></pre></td></tr></table></figure>
<p>注意：只能通过removeEventListener()解绑有名字的函数，对于绑定的匿名函数无法解除绑定。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">div2.addEventListener(<span class="string">"click"</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">'test'</span>);</div><div class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>);</div><div class="line">&#125;, <span class="literal">true</span>);</div><div class="line"></div><div class="line">div2.removeEventListener(<span class="string">"click"</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">"test"</span>);</div><div class="line">&#125;, <span class="literal">true</span>);</div><div class="line">div2.onclick = <span class="literal">null</span>;</div><div class="line"><span class="comment">// 点击div2依然打印出test</span></div></pre></td></tr></table></figure>
<p>注意：这里this指向触发事件的元素自身。</p>
<blockquote>
<p>attachEvent()、detachEvent()</p>
</blockquote>
<p>IE8及以下使用这两个方法绑定和解绑事件，当然，IE9+也支持这个事件。但这个方法绑定的事件默认为冒泡也只有冒泡。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 这里需要在事件前加 on</span></div><div class="line">div2.attachEvent(<span class="string">"onclick"</span>, listener1);</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">listener1</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">'test'</span>);</div><div class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>);</div><div class="line">&#125;</div><div class="line">div2.detachEvent(<span class="string">"onclick"</span>, listener1);</div></pre></td></tr></table></figure></p>
<p>和addEventListener()一样，也不能解绑匿名函数。<br>注意：这里this指向 window。</p>
<blockquote>
<p>阻止默认事件和冒泡</p>
</blockquote>
<p>标准事件和IE事件中的阻止默认事件和冒泡事件也有很大区别。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> div2 = <span class="built_in">document</span>.getElementById(<span class="string">"div2"</span>);</div><div class="line"><span class="keyword">if</span> (div2.addEventListener) &#123;</div><div class="line">    div2.addEventListener(<span class="string">"click"</span>, <span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;</div><div class="line">        e.preventDefault(); <span class="comment">// 阻止默认事件</span></div><div class="line">        e.stopPropagation(); <span class="comment">// 阻止冒泡</span></div><div class="line">        <span class="built_in">console</span>.log(e.target.innerHTML);</div><div class="line">    &#125;, <span class="literal">false</span>);</div><div class="line">&#125; <span class="keyword">else</span> &#123;</div><div class="line">    div2.attachEvent(<span class="string">"onclick"</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="keyword">var</span> e = <span class="built_in">window</span>.event;</div><div class="line">        e.returnValue = <span class="literal">false</span>; <span class="comment">// 阻止默认事件</span></div><div class="line">        e.cancelBubble = <span class="literal">true</span>; <span class="comment">// 阻止冒泡</span></div><div class="line">        <span class="built_in">console</span>.log(e.srcElement.innerHTML);</div><div class="line">    &#125;);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>IE8及以下的event是绑定在window上的。（我的IE11里，仿真到IE7、IE8也可以取到标准事件里的 e 对象，估计是升级到IE11的原因）。</p>
<blockquote>
<p>自定义事件：createEvent()</p>
</blockquote>
<p>createEvent()用于创建一个新的 event ，而后这个 event 必须调用它的 init() 方法进行初始化。最后就可以在目标元素上使用dispatchEvent()调用新创建的event事件了。</p>
<p>createEvent()的参数一般有：UIEvents、MouseEvents、MutationEvents、HTMLEvents、Event(s)等等，分别有对应的init()方法。HTMLEvents、Event(s)对应的都是initEvent()方法。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">initEvent(type, bubbles, cancelable)</div></pre></td></tr></table></figure>
<p>type表示自定义的事件类型，bubbles表示是否冒泡，cancelable表示是否阻止默认事件。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">target.dispatchEvent(ev)</div></pre></td></tr></table></figure>
<p>target就是要触发自定义事件的DOM元素<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">var div1 = document.getElementById(&quot;div1&quot;);</div><div class="line">div1.addEventListener(&quot;message&quot;, function()&#123;</div><div class="line">  console.log(&apos;test&apos;);</div><div class="line">&#125;, false);</div><div class="line"></div><div class="line">var div2 = document.getElementById(&quot;div2&quot;);</div><div class="line">div2.addEventListener(&quot;message&quot;, function(e)&#123;</div><div class="line">  console.log(this);</div><div class="line">  console.log(e);</div><div class="line">&#125;, false);</div><div class="line">var ev = document.createEvent(&quot;Event&quot;);</div><div class="line">ev.initEvent(&quot;message&quot;, false, true); // 起泡参数变为true，div1的事件就会触发</div><div class="line">div2.dispatchEvent(ev);</div></pre></td></tr></table></figure></p>
<h1 id="获取元素相关计算后的值"><a href="#获取元素相关计算后的值" class="headerlink" title="获取元素相关计算后的值"></a>获取元素相关计算后的值</h1><blockquote>
<p>getComputedStyle()、currentStyle()</p>
</blockquote>
<p>当我们想获取元素计算后实际呈现在页面上的各个值，就用这两个方法。IE8及以下用currentStyle(),IE9+及其他标准浏览器用getComputedStyle()。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> div2 = <span class="built_in">document</span>.getElementById(<span class="string">"div2"</span>);</div><div class="line"><span class="keyword">var</span> result = <span class="string">""</span>;</div><div class="line"><span class="keyword">if</span> (<span class="built_in">window</span>.getComputedStyle) &#123;</div><div class="line">    result = (<span class="built_in">window</span> || <span class="built_in">document</span>.defaultView).getComputedStyle(div2, <span class="literal">null</span>)[<span class="string">'cssFloat'</span>];</div><div class="line">&#125; <span class="keyword">else</span> &#123;</div><div class="line">    result = div2.currentStyle[<span class="string">"styleFloat"</span>];</div><div class="line">&#125;</div><div class="line"><span class="built_in">console</span>.log(result);</div><div class="line"><span class="comment">// document.defaultView返回document对象所关联的window</span></div></pre></td></tr></table></figure></p>
<p>这两个方法在不同的浏览器里差距也很大。<br>比如float属性：<br>getComputedStyle： IE9以上需要用cssFloat，其他标准的用float<br>currentStyle： IE8及以下可用styleFloat或者float。</p>
<p>比如height属性：<br>假如未设置height值，标准浏览器里能计算出高度值，而currentStyle计算出来是auto。</p>
<p>上面的例子getComputedStyle是用键值去访问的，也可用getPropertyValue()去访问。（IE8、IE7不支持）</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">result = (<span class="built_in">window</span> || <span class="built_in">document</span>.defaultView).getComputedStyle(div2, <span class="literal">null</span>).getPropertyValue(<span class="string">"float"</span>);</div></pre></td></tr></table></figure>
<blockquote>
<p>getBoundingClientRect()、getClientRects()</p>
</blockquote>
<p>getBoundingClientRect()该方法获得页面中某个元素的上、右、下、左分别相对浏览器视窗的位置。getBoundingClientRect是DOM元素到浏览器可视范围的距离（到浏览器顶部而不是文档顶部）。该函数返回一个Object对象，该对象有6个属性：top,lef,right,bottom,width,height；这里的top、left和css中的理解很相似，width、height是元素自身的宽高，但是right，bottom和css中的理解有点不一样。right是指元素右边界距窗口最左边的距离，bottom是指元素下边界距窗口最上面的距离。</p>
<p>getClientRects()是返回一个ClientRectList集合。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> div1 = <span class="built_in">document</span>.getElementById(<span class="string">"div1"</span>);</div><div class="line"><span class="keyword">var</span> rects1 = div1.getClientRects();</div><div class="line"><span class="keyword">var</span> rects2 = div1.getBoundingClientRect();</div><div class="line"><span class="built_in">console</span>.log(rects1[<span class="number">0</span>].top);</div><div class="line"><span class="built_in">console</span>.log(rects2.top);</div></pre></td></tr></table></figure>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="https://sunzhen086.github.io/blog/blog/content/viewport和media query/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="sunzhen">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="https://avatars3.githubusercontent.com/u/16077783?s=200">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="孙振的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/blog/content/viewport和media query/" itemprop="url">
                  viewport和media query
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-04-11T15:44:00+08:00">
                2017-04-11
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="viewport"><a href="#viewport" class="headerlink" title="viewport"></a>viewport</h1><h3 id="width-device-width"><a href="#width-device-width" class="headerlink" title="width=device-width:"></a>width=device-width:</h3><p>你可以定义viewport的宽度.如果你不使用width=device-width,在移动端上你的页面延伸会超过视窗布局的宽度(width=980px),如果你使用了width=device-width,你的页面将会显示为合适的移动端宽度(width=320px),我们可以使用meta标记:<br><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"viewport"</span> <span class="attr">content</span>=<span class="string">"width=device-width"</span>&gt;</span></div></pre></td></tr></table></figure></p>
<p>我们看见很多网站都建议把content属性的值设置为width=device-width。这相当于告诉浏览器将页面宽度假设为设备宽度。不幸的是，只有当设备是纵向时假设才是正确的。当我们把设备旋转成横向时，device-width还是和纵向的一样（比如，320px），这意味着，即使我们把页面设计成适应了480px横向设备，它还是会返回320px的效果。<br>如果我们的页面在纵向和横向设备中样式相同，那么我们就可以用width=device-width就足够了，需要注意的是这个是唯一告诉android设备使用设备宽度的方法。</p>
<h3 id="initial-scale-1-0-maximum-scale-1-0"><a href="#initial-scale-1-0-maximum-scale-1-0" class="headerlink" title="initial-scale=1.0,maximum-scale=1.0"></a>initial-scale=1.0,maximum-scale=1.0</h3><p> 在大多数手机上,默认的缩放在手机浏览器上可能会触发”zoom”.为了阻止用户缩放,你可以设置initial-scale=1.0,下面是移动视窗的完整写法:<br> <figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"viewport"</span> <span class="attr">content</span>=<span class="string">"width=device-width, initial-scale=1.0"</span>&gt;</span></div></pre></td></tr></table></figure></p>
<h1 id="Media-Queries"><a href="#Media-Queries" class="headerlink" title="Media Queries"></a>Media Queries</h1><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">@<span class="keyword">media</span> screen and (max-width: <span class="number">600px</span>) &#123; <span class="comment">/*当屏幕尺寸小于600px时，应用下面的CSS样式*/</span></div><div class="line">  <span class="selector-class">.class</span> &#123;</div><div class="line">    <span class="attribute">background</span>: <span class="number">#ccc</span>;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>要注意的是由于网页会根据屏幕宽度调整布局，所以不能使用绝对宽度的布局，也不能使用具有绝对宽度的元素。这一条非常重要，否则会出现横向滚动条。 </p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
  </section>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/blog/page/2/">2</a><a class="extend next" rel="next" href="/blog/page/2/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      

      <section class="site-overview sidebar-panel sidebar-panel-active">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="https://avatars3.githubusercontent.com/u/16077783?s=200"
               alt="sunzhen" />
          <p class="site-author-name" itemprop="name">sunzhen</p>
           
              <p class="site-description motion-element" itemprop="description"><i class="fa fa-github" style="font-size:20px"></i><br /> <a href="https://github.com/sunzhen086">github主页</a></p>
          
        </div>
        <nav class="site-state motion-element">

          
            <div class="site-state-item site-state-posts">
              <a href="/blog/archives">
                <span class="site-state-item-count">19</span>
                <span class="site-state-item-name">日志</span>
              </a>
            </div>
          

          

          
            
            
            <div class="site-state-item site-state-tags">
              <a href="/blog/tags/index.html">
                <span class="site-state-item-count">7</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
        </div>

        
        

        
        

        


      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2017</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">sunzhen</span>
</div>


<div class="powered-by">
  由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Pisces
  </a>
</div>


        

        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  






  
  <script type="text/javascript" src="/blog/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/blog/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/blog/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/blog/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/blog/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/blog/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/blog/js/src/utils.js?v=5.1.0"></script>

  <script type="text/javascript" src="/blog/js/src/motion.js?v=5.1.0"></script>



  
  


  <script type="text/javascript" src="/blog/js/src/affix.js?v=5.1.0"></script>

  <script type="text/javascript" src="/blog/js/src/schemes/pisces.js?v=5.1.0"></script>



  

  


  <script type="text/javascript" src="/blog/js/src/bootstrap.js?v=5.1.0"></script>



  


  




	





  





  





  






  





  

  

  

  

</body>
</html>
